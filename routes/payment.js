const express = require('express');
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
const axios = require('axios');
const { generateBinancePayHeaders } = require('../utilities/binancePayUtils');
const { logger } = require('../utilities/logger');
require('dotenv').config();
const router = express.Router();
const db = require('../database');
const { transporter } = require('../mailer');

const ADMINISTRATION_AND_ONE_YEAR_SIGNAL_FEE = 15;
const STRIPE_PROCESSING_FEE_PERCENTAGE = 4.2 / 100;

const DIRECT_COMMISSION_PERCENTAGE = 10 / 100;
const CASH_BACK_BONUS_PERCENTAGE = 19 / 100;
const REFERRAL_POINT_USD_VALUE = 3;

function calculateTotalCharge(productPrice) {
	const flatFee = 1.0;

	return Math.ceil((productPrice + flatFee) / (1 - STRIPE_PROCESSING_FEE_PERCENTAGE));
}

// Stripe payment endpoint
router.get('/get-products/:currentPlan', async (req, res) => {
	const { currentPlan } = req.params;

	const isCurrentPlanAnInteger = Number.isInteger(parseInt(currentPlan));

	const plan = isCurrentPlanAnInteger ? parseInt(currentPlan) + 1 : 1;
	const result = await db.query('SELECT * FROM products WHERE id = ?', [plan]);

	const planData = result[0];

	const administrationFee = isCurrentPlanAnInteger ? 0 : ADMINISTRATION_AND_ONE_YEAR_SIGNAL_FEE;

	const total = planData.product_price + administrationFee;

	const fullTotal = calculateTotalCharge(total);

	res.json({
		...planData,
		administrationFee,
		total,
		stripeTotal: fullTotal * 100,
	});
});

router.post('/create-payment-intent', async (req, res) => {
	const { firstName, lastName, email, address, amount, description } = req.body; // 'source' is the token id generated by Stripe on the frontend
	try {
		const customer = await stripe.customers.create({ name: `${firstName} ${lastName}`, email });

		const paymentIntent = await stripe.paymentIntents.create({
			amount: amount,
			currency: 'usd',
			description: 'Forex Trading Master Course, including Administration Fee and 1-Year Signal Service.',
			automatic_payment_methods: {
				enabled: true,
			},
			customer: customer.id,
		});
		res.json({ success: true, clientSecret: paymentIntent.client_secret });
	} catch (error) {
		logger.error('Stripe Charge Error:', error);
		res.status(500).json({ success: false, error: error.message });
	}
});

// A one-time bonus when a member reaches 1:1 referrals on both sides
async function addCashBackBonus(member_id, sp_A, sp_B, cash_back) {
	const sideAReferralPoints = parseFloat(sp_A) ?? 0;
	const sideBReferralPoints = parseFloat(sp_B) ?? 0;
	const currentCashBackValue = cash_back ?? 0;

	const isEligible = sideAReferralPoints === 1 && sideBReferralPoints === 1 && currentCashBackValue === 0;

	if (isEligible) {
		// Get starter plan data
		const result = await db.query('SELECT * FROM products WHERE id = 1');
		if (result.length <= 0) throw Error('Failed to add cash back bonus because plan data cannot be found.');

		const planData = result[0];

		// plan price is multiplied by 2 to select 1:1 referral points from both sp_A and sp_B sides
		const bonus = planData.product_price * 2 * CASH_BACK_BONUS_PERCENTAGE;

		await db.query('UPDATE fx_users SET cash_back = ? WHERE member_id = ?', [bonus, member_id]);
	}
}

async function addReferralBonuses(member_id, sp_A, sp_B) {
	const eligibleReferralPoints = Math.floor(Math.min(parseFloat(sp_A), parseFloat(sp_B)));
	const isEligible = eligibleReferralPoints >= 1;

	if (isEligible) {
		const updatedSpA = sp_A - eligibleReferralPoints;
		const updatedSpB = sp_B - eligibleReferralPoints;

		// Eligible referral bonus is multiplied by 2 to select referral points from both sp_A and sp_B sides
		const bonus = eligibleReferralPoints * 2 * REFERRAL_POINT_USD_VALUE;

		await db.query('UPDATE fx_users SET binary_commission = ?, sp_A = ?, sp_B = ? WHERE member_id = ?', [
			bonus,
			updatedSpA,
			updatedSpB,
			member_id,
		]);
	}
}

async function addReferralPointsToParents(referral_points, current_user_id, parentLinkingReferralType, level = 1) {
	const output = { modifiedMembers: [], level };
	const referralSide = parentLinkingReferralType === 'A' ? 'referral_side_A_member_id' : 'referral_side_B_member_id';
	const referralPointsSide = parentLinkingReferralType === 'A' ? 'sp_A' : 'sp_B';
	const otherReferralPointsSide = parentLinkingReferralType === 'B' ? 'sp_A' : 'sp_B';

	const q = await db.query(`SELECT * FROM fx_users WHERE ${referralSide} = ?`, [current_user_id]);

	if (q.length > 0) {
		const parent = q[0];
		const currentReferralPoints = parent[referralPointsSide] ?? 0;
		const updatedReferralPoints = currentReferralPoints + referral_points;

		await db.query(`UPDATE fx_users SET ${referralPointsSide} = ? WHERE member_id = ?`, [
			updatedReferralPoints,
			parent.member_id,
		]);

		output.modifiedMembers.push(parent.member_id);

		const obj = {};
		obj[referralPointsSide] = updatedReferralPoints;
		obj[otherReferralPointsSide] = parent[otherReferralPointsSide] ?? 0;

		// ! Awaiting these will degrade performance
		await addReferralBonuses(parent.member_id, obj.sp_A, obj.sp_B);
		await addCashBackBonus(parent.member_id, obj.sp_A, obj.sp_B, parent.cash_back);

		const data = await addReferralPointsToParents(referral_points, parent.member_id, parent.referral_type, level + 1);
		output.modifiedMembers.push(...data.modifiedMembers);
		output.level = data.level;
	}

	return output;
}

const addDirectCommissionToIntroducer = async (introducer_id, plan_price) => {
	const directCommission = parseInt(plan_price) * DIRECT_COMMISSION_PERCENTAGE;

	const data = await db.query('SELECT * FROM fx_users WHERE member_id = ?', [introducer_id]);
	if (data.length <= 0) throw new Error('Introducer cannot be found when adding direct commission.');

	const introducer = data[0];
	const currentDirectSales = parseInt(introducer.direct_sales);
	const updatedDirectSales = currentDirectSales + directCommission;

	await db.query('UPDATE fx_users SET direct_sales = ? WHERE member_id = ?', [
		updatedDirectSales,
		introducer.member_id,
	]);
};

router.get('/verify-payment', async (req, res) => {
	const {
		payment_intent,
		payment_intent_client_secret,
		redirect_status,
		member_id,
		introducer,
		plan,
		referral_points,
		referral_type,
		amount,
	} = req.query;

	try {
		const q = await db.query('SELECT * FROM products WHERE id = ?', [plan]);
		if (q.length <= 0) throw new Error('Plan with given id cannot be found.');

		const planData = q[0];

		const q1 = await db.query('SELECT * FROM fx_users WHERE member_id = ?', [member_id]);
		if (q1.length <= 0) throw new Error('User with given id cannot be found.');

		const user = q1[0];

		// if plan id equals to 1 (Starter plan), add the direct commission to the introducer.
		if (parseInt(plan) === 1) addDirectCommissionToIntroducer(user.introducer, planData.product_price);

		// TODO : More payment verification required

		await db.query('UPDATE `fx_users` SET profile_status = ?, activation_date = NOW(), plan = ? WHERE member_id = ?', [
			'Activated',
			parseInt(plan),
			parseInt(member_id),
		]);
		await db.query('INSERT INTO transactions(amount, payment_intent, member_id, plan) VALUES (?, ?, ?, ?)', [
			parseFloat(amount),
			payment_intent,
			parseInt(member_id),
			parseInt(plan),
		]);

		const data = await addReferralPointsToParents(
			parseInt(planData.referral_points),
			parseInt(user.member_id),
			user.referral_type
		);

		res.json({ success: true, ...data });
	} catch (error) {
		console.error(error);
		res.json({ status: 500, message: error.message });
	}
});

router.post('/verify-binance-payment', async (req, res) => {
	const { trx, member_id, amount, plan_id } = req.body;

	const mailOptions = {
		from: process.env.SMTP_USER,
		to: process.env.BINANCE_PAYMENT_VERIFY_EMAIL,
		cc: [process.env.BINANCE_PAYMENT_SECOND_VERIFY_EMAIL],
		subject: 'Verify Binance Payment',
		html: `<p>You have received a Payment of  ${amount} USD from ${member_id}, Transaction ID is ${trx}. Plan ${plan_id}</p>`,
	};

	try {
		await db.query('INSERT INTO transactions(amount, payment_intent, member_id, plan) VALUES (?, ?, ?, ?)', [
			parseFloat(amount),
			trx,
			parseInt(member_id),
			parseInt(plan_id),
		]);

		await transporter.sendMail(mailOptions);
		logger.info('Email to verify binance payment sent.');
	} catch (error) {
		logger.error('Failed to send email to verify binance payment:', error);
		throw new Error('Failed to send email to verify binance payment');
	}
	// console.log('Binance', { ...req.body });
	res.json({ success: true });
});

// Binance Pay payment endpoint (Corrected and updated version)
router.post('/binancepay', async (req, res) => {
	const requestBody = JSON.stringify(req.body);
	const apiKey = process.env.BINANCE_PAY_CERTIFICATE_SN;
	const secretKey = process.env.BINANCE_PAY_SECRET_KEY;

	const headers = generateBinancePayHeaders(apiKey, secretKey, requestBody);

	try {
		// Ensure you're using the correct Binance Pay URL and endpoint
		const response = await axios.post('https://bpay.binanceapi.com/binancepay/openapi/v1/order', requestBody, {
			headers,
		});
		res.json(response.data);
	} catch (error) {
		logger.error('Error making Binance Pay request:', error.response ? error.response.data : error);
		res.status(500).json({ message: 'Failed to process payment with Binance Pay' });
	}
});

module.exports = router;
