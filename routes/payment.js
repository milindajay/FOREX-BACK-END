const express = require('express');
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
const axios = require('axios');
const { generateBinancePayHeaders } = require('../utilities/binancePayUtils');
const { logger } = require('../utilities/logger');
require('dotenv').config();
const router = express.Router();
const db = require('../database');

const ADMINISTRATION_AND_ONE_YEAR_SIGNAL_FEE = 15;
const STRIPE_PROCESSING_FEE_PERCENTAGE = 4.2 / 100;

function calculateTotalCharge(productPrice) {
	const flatFee = 1.0;

	return Math.ceil((productPrice + flatFee) / (1 - STRIPE_PROCESSING_FEE_PERCENTAGE));
}

// Stripe payment endpoint
router.get('/get-products/:currentPlan', async (req, res) => {
	const { currentPlan } = req.params;

	const isCurrentPlanAnInteger = Number.isInteger(parseInt(currentPlan));

	const plan = isCurrentPlanAnInteger ? parseInt(currentPlan) + 1 : 1;
	const result = await db.query('SELECT * FROM products WHERE id = ?', [plan]);

	const planData = result[0];

	const administrationFee = isCurrentPlanAnInteger ? 0 : ADMINISTRATION_AND_ONE_YEAR_SIGNAL_FEE;

	const total = planData.product_price + administrationFee;

	const fullTotal = calculateTotalCharge(total);

	res.json({
		...planData,
		administrationFee,
		total: fullTotal,
		stripeTotal: fullTotal * 100,
	});
});

router.post('/create-payment-intent', async (req, res) => {
	const { firstName, lastName, email, address, amount, description } = req.body; // 'source' is the token id generated by Stripe on the frontend
	try {
		const customer = await stripe.customers.create({ name: `${firstName} ${lastName}`, email });

		const paymentIntent = await stripe.paymentIntents.create({
			amount: amount,
			currency: 'usd',
			description: 'Forex Trading Master Course, including Administration Fee and 1-Year Signal Service.',
			automatic_payment_methods: {
				enabled: true,
			},
			customer: customer.id,
		});
		res.json({ success: true, clientSecret: paymentIntent.client_secret });
	} catch (error) {
		logger.error('Stripe Charge Error:', error);
		res.status(500).json({ success: false, error: error.message });
	}
});

async function addReferralPointsToParents(referral_points, current_user_id, referral_type, level = 1) {
	const output = { modifiedMembers: [], level };
	const referralSide = referral_type === 'A' ? 'referral_side_A_member_id' : 'referral_side_B_member_id';
	const referralPointsSide = referral_type === 'A' ? 'sp_A' : 'sp_B';

	const q = await db.query(`SELECT * FROM fx_users WHERE ${referralSide} = ?`, [current_user_id]);

	if (q.length > 0) {
		const parent = q[0];
		const currentReferralPoints = parent[referralPointsSide] ?? 0;

		await db.query(`UPDATE fx_users SET ${referralPointsSide} = ? WHERE member_id = ?`, [
			currentReferralPoints + referral_points,
			parent.member_id,
		]);

		output.modifiedMembers.push(parent.member_id);

		const data = await addReferralPointsToParents(referral_points, parent.member_id, referral_type);
		output.modifiedMembers.push(...data.modifiedMembers);
		output.level = data.level;
	}

	return output;
}

router.get('/verify-payment', async (req, res) => {
	const {
		payment_intent,
		payment_intent_client_secret,
		redirect_status,
		member_id,
		introducer,
		plan,
		referral_points,
		referral_type,
		amount,
	} = req.query;

	try {
		const q = await db.query('SELECT * FROM products WHERE id = ?', [plan]);
		if (q.length <= 0) throw new Error('Plan with given id cannot be found.');

		const planData = q[0];

		const q1 = await db.query('SELECT * FROM fx_users WHERE member_id = ?', [member_id]);
		if (q1.length <= 0) throw new Error('User with given id cannot be found.');

		const user = q1[0];

		// const referralSide = user.referral_type === 'A' ? 'referral_side_A_member_id' : 'referral_side_B_member_id';

		// const parentId = user[referralSide];

		// TODO : First direct commission handling

		// TODO : More payment verification required

		await db.query('UPDATE `fx_users` SET profile_status = ?, activation_date = NOW(), plan = ? WHERE member_id = ?', [
			'Activated',
			parseInt(plan),
			parseInt(member_id),
		]);
		await db.query('INSERT INTO transactions(amount, payment_intent, member_id, plan) VALUES (?, ?, ?, ?)', [
			parseFloat(amount),
			payment_intent,
			parseInt(member_id),
			parseInt(plan),
		]);

		const data = await addReferralPointsToParents(
			parseInt(planData.referral_points),
			parseInt(user.member_id),
			user.referral_type
		);

		res.json({ success: true, ...data });
	} catch (error) {
		console.error(error);
		res.json({ status: 500, message: error.message });
	}
});

// Binance Pay payment endpoint (Corrected and updated version)
router.post('/binancepay', async (req, res) => {
	const requestBody = JSON.stringify(req.body);
	const apiKey = process.env.BINANCE_PAY_CERTIFICATE_SN;
	const secretKey = process.env.BINANCE_PAY_SECRET_KEY;

	const headers = generateBinancePayHeaders(apiKey, secretKey, requestBody);

	try {
		// Ensure you're using the correct Binance Pay URL and endpoint
		const response = await axios.post('https://bpay.binanceapi.com/binancepay/openapi/v1/order', requestBody, {
			headers,
		});
		res.json(response.data);
	} catch (error) {
		logger.error('Error making Binance Pay request:', error.response ? error.response.data : error);
		res.status(500).json({ message: 'Failed to process payment with Binance Pay' });
	}
});

module.exports = router;
